'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMacOS = exports.parseMacOSToProps = exports.parseNodeId = exports.addEmptyNode = exports.addEmptyVolumeToDevice = exports.addEmptyDevice = exports.getPropsTarget = exports.nodeType = exports.macOSFS = exports.getMacOSBytes = exports.COMMAND = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _functional = require('../functional');

var _functional2 = _interopRequireDefault(_functional);

var _utilities = require('../utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var each = _functional2.default.each;
var filter = _functional2.default.R.filter;
var COMMAND = exports.COMMAND = 'diskutil info -all';

var getMacOSBytes = exports.getMacOSBytes = function getMacOSBytes(str) {
  return parseInt(str.match(/\((\d+) Bytes\)/)[1]);
};

var macOSFS = exports.macOSFS = function macOSFS(fs) {
  switch (fs) {
    case 'ExFAT':
      return 'ExFAT';
    case 'MS-DOS':
      return 'FAT';
    case 'MS-DOS FAT12':
      return 'FAT12';
    case 'MS-DOS FAT16':
      return 'FAT16';
    case 'MS-DOS FAT32':
    case 'fat32':
      return 'FAT32';
    case 'HFS+':
    case 'Case-sensitive HFS+':
    case 'hfsx':
    case 'Case-sensitive Journaled HFS+':
    case 'jhfsx':
    case 'Journaled HFS+':
    case 'jhfs+':
      return 'HFS+';
    case 'Free Space':
    case 'free':
    default:
      return null;
  }
};

/* lower order functions for parseMacOS */

// Tells you whether this is a volume or a device
var nodeType = exports.nodeType = function nodeType(node) {
  return node.space ? 'volume' : 'device';
};

// Gets target device / volume for parseMacOSToProps
var getPropsTarget = exports.getPropsTarget = function getPropsTarget(acc, _ref) {
  var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
      devid = _ref2[0],
      id = _ref2[1];

  return id ? acc.devices[devid].volumes[id] : acc.devices[devid];
};

// Adds an empty device to accumulator
var addEmptyDevice = exports.addEmptyDevice = function addEmptyDevice(acc) {
  return function (id) {
    acc.devices[id] = (0, _utilities.emptyDevice)();
  };
};

// Adds an empty volume to its parent device
var addEmptyVolumeToDevice = exports.addEmptyVolumeToDevice = function addEmptyVolumeToDevice(device) {
  return function (id) {
    device.volumes = device.volumes ? device.volumes : {};
    device.volumes[id] = (0, _utilities.emptyVolume)();
  };
};

// Adds an empty device / volume based off wether a volume id is provided
var addEmptyNode = exports.addEmptyNode = function addEmptyNode(addEmptyDevice, addEmptyVolumeToDevice) {
  return function (acc, _ref3) {
    var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
        devid = _ref4[0],
        id = _ref4[1];

    return id ? addEmptyVolumeToDevice(acc.devices[devid])(id) : addEmptyDevice(acc)(devid);
  };
};

// Finds the device id as well as the volume id (where applicable) from the provided input lines
var parseNodeId = exports.parseNodeId = function parseNodeId(acc, lines) {
  var id = lines.find(function (l) {
    return l.match('Device Identifier');
  }).match(/:\s+(.*)/)[1];
  var devid = (0, _keys2.default)(acc.devices).find(function (dev) {
    return id.match('^' + dev);
  });

  return devid ? [devid, id] : [id, undefined];
};

// Maps received line to a property on the node
var parseMacOSToProps = exports.parseMacOSToProps = function parseMacOSToProps(macOSFS, getMacOSBytes) {
  var PROPERTY_MAP = {
    'Device Identifier': {
      target: 'dual',
      key: 'id',
      mapper: function mapper(node, value) {
        node.id = value;
      }
    },
    'Device Node': {
      target: 'dual',
      key: 'node',
      mapper: function mapper(node, value) {
        node.node = value;
      }
    },
    'Whole': {
      target: 'dual',
      key: 'whole',
      mapper: function mapper(node, value) {
        node.whole = (0, _utilities.getYesNo)(value);
      }
    },
    'Part of Whole': {
      target: 'dual',
      key: 'parent',
      mapper: function mapper(node, value) {
        node.parent = value;
      }
    },
    'Device / Media Name': {
      target: 'dual',
      key: 'description',
      mapper: function mapper(node, value) {
        node.description = value;
      }
    },
    'Volume Name': {
      target: 'dual',
      key: 'name',
      mapper: function mapper(node, value) {
        node.name = (0, _utilities.hasSubstr)(value, 'Not applicable') ? null : value;
      }
    },
    'Mounted': {
      target: 'dual',
      key: 'mounted',
      mapper: function mapper(node, value) {
        node.mounted = !(0, _utilities.hasSubstr)(value, 'Not applicable');
      }
    },
    'Mount Point': {
      target: 'dual',
      key: 'mountPoint',
      mapper: function mapper(node, value) {
        node.mountPoint = (0, _utilities.hasSubstr)(value, 'Not applicable') ? null : value;
      }
    },
    'File System Personality': {
      target: 'volume',
      key: 'fs',
      mapper: function mapper(node, value) {
        node.fs = macOSFS(value);
      }
    },
    'Partition Type': {
      target: 'volume',
      key: 'partitionType',
      mapper: function mapper(node, value) {
        node.partitionType = value;
      }
    },
    'Protocol': {
      target: 'device',
      key: 'protocol',
      mapper: function mapper(node, value) {
        node.protocol = value;
      }
    },
    'Disk Size': {
      target: 'device',
      key: 'size',
      mapper: function mapper(node, value) {
        node.size = getMacOSBytes(value);
      }
    },
    'Total Size': {
      target: 'device',
      key: 'size',
      mapper: function mapper(node, value) {
        node.size = node.size || getMacOSBytes(value);
      }
    },
    'Device Block Size': {
      target: 'device',
      key: 'blockSize',
      mapper: function mapper(node, value) {
        node.blockSize = parseInt(value.match(/\d+/)[0]);
      }
    },
    'Volume Total Space': {
      target: 'volume',
      key: 'space.total',
      mapper: function mapper(node, value) {
        node.space.total = getMacOSBytes(value);
      }
    },
    'Volume Used Space': {
      target: 'volume',
      key: 'space.used',
      mapper: function mapper(node, value) {
        node.space.used = getMacOSBytes(value);
      }
    },
    'Volume Available Space': {
      target: 'volume',
      key: 'space.available',
      mapper: function mapper(node, value) {
        node.space.available = getMacOSBytes(value);
        if (node.space.total !== null && node.space.used === null) {
          node.space.used = node.space.total - node.space.available;
        }
      }
    },
    'Volume Free Space': {
      target: 'volume',
      key: 'space.available',
      mapper: function mapper(node, value) {
        node.space.available = getMacOSBytes(value);
        if (node.space.total !== null && node.space.used === null) {
          node.space.used = node.space.total - node.space.available;
        }
      }
    },
    'Allocation Block Size': {
      target: 'volume',
      key: 'blockSize',
      mapper: function mapper(node, value) {
        node.blockSize = parseInt(value.match(/\d+/)[0]);
      }
    },
    'Read-Only Media': {
      target: 'device',
      key: 'readOnly',
      mapper: function mapper(node, value) {
        node.readOnly = (0, _utilities.getYesNo)(value);
      }
    },
    'Read-Only Volume': {
      target: 'dual',
      key: 'readOnly',
      mapper: function mapper(node, value) {
        node.readOnly = (0, _utilities.hasSubstr)(value, 'Not applicable (not mounted)') ? null : (0, _utilities.getYesNo)(value);
      }
    },
    'Removable Media': {
      target: 'device',
      key: 'removable',
      mapper: function mapper(node, value) {
        node.removable = value === 'Fixed';
      }
    }
  };

  return function (node, key, value) {
    // Property ought to be mapped on current node
    if (PROPERTY_MAP[key] && PROPERTY_MAP[key].target === nodeType(node)) {
      PROPERTY_MAP[key].mapper(node, value);
      return node;
    }

    // Property ought to be mapped on both device and volume
    if (PROPERTY_MAP[key] && PROPERTY_MAP[key].target === 'dual') {
      PROPERTY_MAP[key].mapper(node, value);
      if (node.volumes && node.volumes[node.id]) {
        PROPERTY_MAP[key].mapper(node.volumes[node.id], value);
      }
      return node;
    }

    // Property ought to be mapped on volume but current node is a device => dual
    if (PROPERTY_MAP[key] && PROPERTY_MAP[key].target === 'volume' && nodeType(node) === 'device') {
      if (!(node.volumes && node.volumes[node.id])) {
        addEmptyVolumeToDevice(node)(node.id);
        each(function (_ref5) {
          var target = _ref5.target,
              key = _ref5.key;
          if (target === 'dual') node.volumes[node.id][key] = node[key];
        }, PROPERTY_MAP);
      }
      PROPERTY_MAP[key].mapper(node.volumes[node.id], value);
      return node;
    }

    // Property ought to be mapped on device but current node is a volume
    // or property is not in PROPERTY_MAP
    return node;
  };
};

// Parses output of COMMAND to an object
var parseMacOS = exports.parseMacOS = function parseMacOS(getPropsTarget, addEmptyNode, parseNodeId, parseMacOSToProps) {
  return function (userFilter) {
    return function (output) {
      var entries = output.split(/\*{10}/) // Split per entry
      .filter(function (s) {
        return s.trim();
      }); // Remove empty blocks

      // reduce input entries to device / volume objects and return accumulator
      var accumulator = entries.reduce(function (acc, entry) {
        var lines = entry.split('\n') // Split by line
        .map(function (s) {
          return s.trim();
        }) // Trim whitespace
        .filter(function (s) {
          return s;
        }); // Remove empty lines

        var identifiers = parseNodeId(acc, lines);
        addEmptyNode(acc, identifiers);

        lines.reduce(function (target, line) {
          return parseMacOSToProps.apply(undefined, [target].concat((0, _toConsumableArray3.default)(line.split(/:\s+/))));
        }, getPropsTarget(acc, identifiers));

        return acc;
      }, { devices: {} });

      accumulator.devices = (0, _entries2.default)(accumulator.devices).map(function (_ref6) {
        var _ref7 = (0, _slicedToArray3.default)(_ref6, 2),
            k = _ref7[0],
            dev = _ref7[1];

        return [k, (0, _extends3.default)({}, dev, {
          volumes: dev.volumes ? (0, _keys2.default)(dev.volumes).map(function (k) {
            return dev.volumes[k];
          }) : []
        })];
      }).reduce(function (acc, _ref8) {
        var _ref9 = (0, _slicedToArray3.default)(_ref8, 2),
            k = _ref9[0],
            dev = _ref9[1];

        acc[k] = dev;
        return acc;
      }, {});

      // Filter devices according to userFilter
      return {
        devices: filter(userFilter, accumulator.devices)
      };
    };
  };
};