'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseLinux = exports.parsedfT = exports.splitdfTLine = exports.parsefdiskl = exports.parsefdisklVolumeData = exports.parsefdisklDeviceData = exports.parselsblk = exports.parselsblkVolumeData = exports.parselsblkDeviceData = exports.mergeVolumesAndDevicesLinux = exports.createNewVolume = exports.createNewDevice = exports.getNodeId = exports.COMMAND = undefined;

var _toArray2 = require('babel-runtime/helpers/toArray');

var _toArray3 = _interopRequireDefault(_toArray2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _functional = require('../functional');

var _functional2 = _interopRequireDefault(_functional);

var _utilities = require('../utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _F$R = _functional2.default.R,
    compose = _F$R.compose,
    map = _F$R.map,
    reduce = _F$R.reduce,
    filter = _F$R.filter;
var COMMAND = exports.COMMAND = 'df -T && ' + 'echo "" && echo "**********" && echo "" && ' + 'fdisk -l && ' + 'echo "" && echo "**********" && echo "" && ' + 'lsblk -o kname,fstype,mountpoint,label,ro,rm,model,type -P';

var getNodeId = exports.getNodeId = function getNodeId(node) {
  return (0, _utilities.lasti)(node.split('/').filter(function (s) {
    return s.trim();
  }));
};

var createNewDevice = exports.createNewDevice = function createNewDevice(emptyDevice) {
  return function (id) {
    var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var device = emptyDevice();
    device.id = id;
    device.node = node || '/dev/' + id;
    device.name = id;
    device.whole = true;
    device.parent = id;
    return device;
  };
};

var createNewVolume = exports.createNewVolume = function createNewVolume(emptyVolume) {
  return function (id) {
    var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var volume = emptyVolume();
    volume.id = id;
    volume.node = node || '/dev/' + id;
    volume.name = id;
    volume.parent = id.match(/[a-z]+/)[0];
    return volume;
  };
};

var mergeVolumesAndDevicesLinux = exports.mergeVolumesAndDevicesLinux = function mergeVolumesAndDevicesLinux(emptyDevice) {
  return function (_ref) {
    var devices = _ref.devices,
        volumes = _ref.volumes;

    var vkeys = (0, _keys2.default)(volumes);
    // Merge volumes to devices
    (0, _entries2.default)(devices).forEach(function (_ref2) {
      var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
          key = _ref3[0],
          dev = _ref3[1];

      var vkeysForDev = vkeys.filter(function (k) {
        return (0, _utilities.hasSubstr)(k, key);
      }); // volume keys that belong to current device
      dev.volumes = vkeysForDev.map(function (k) {
        var volume = volumes[k];
        if (dev.volumeBlockSize) volume.blockSize = dev.volumeBlockSize;
        return volume;
      });
    });
    // Remove the volumeBlockSize property from the devices
    return {
      devices: map(function (d) {
        return reduce(function (a, v, k) {
          if (k !== 'volumeBlockSize') a[k] = v;
          return a;
        }, emptyDevice())(d);
      }, devices)
    };
  };
};

// Values Example
// ['sdc1', 'vfat', '/media/user/KINGSTON', 'KINGSTON', '0', '1', '', 'part']
/*
 * 0: KNAME
 * 1: FSTYPE
 * 2: MOUNTPOINT
 * 3: LABEL
 * 4: RO
 * 5: RM
 * 6: MODEL
 * 7: TYPE
 */
var parselsblkDeviceData = exports.parselsblkDeviceData = function parselsblkDeviceData(createNewDevice) {
  return function (acc) {
    return function (_ref4) {
      var _ref5 = (0, _slicedToArray3.default)(_ref4, 8),
          id = _ref5[0],
          fs = _ref5[1],
          mountPoint = _ref5[2],
          label = _ref5[3],
          readOnly = _ref5[4],
          removable = _ref5[5],
          model = _ref5[6],
          _ = _ref5[7];

      if (!acc.devices[id]) {
        acc.devices[id] = createNewDevice(id);
      }
      acc.devices[id].readOnly = !!parseInt(readOnly);
      acc.devices[id].removable = !!parseInt(removable);
      acc.devices[id].description = acc.devices[id].description || label || null;
      return acc;
    };
  };
};

var parselsblkVolumeData = exports.parselsblkVolumeData = function parselsblkVolumeData(createNewVolume) {
  return function (acc) {
    return function (_ref6) {
      var _ref7 = (0, _slicedToArray3.default)(_ref6, 8),
          id = _ref7[0],
          fs = _ref7[1],
          mountPoint = _ref7[2],
          label = _ref7[3],
          readOnly = _ref7[4],
          removable = _ref7[5],
          model = _ref7[6],
          _ = _ref7[7];

      if (!acc.volumes[id]) {
        acc.volumes[id] = createNewVolume(id);
      }
      acc.volumes[id].fs = fs || null;
      acc.volumes[id].mounted = !!mountPoint;
      acc.volumes[id].mountPoint = mountPoint || null;
      acc.volumes[id].readOnly = !!parseInt(readOnly);
      acc.volumes[id].removable = !!parseInt(removable);
      acc.volumes[id].description = acc.volumes[id].description || label || null;
      return acc;
    };
  };
};

var parselsblk = exports.parselsblk = function parselsblk(parselsblkDeviceData, parselsblkVolumeData) {
  return function (lsblk) {
    return function (acc) {
      var lines = lsblk.split('\n') // Split by line
      .filter(function (s) {
        return s.trim();
      }); // Remove empty lines

      lines.forEach(function (line) {
        var fields = line.match(/([A-Z]+="[^"]*")+/g);
        var values = fields.map(function (field) {
          return field.replace(/"/g, '').split('=')[1];
        });

        if (values[values.length - 1] === 'disk') {
          return parselsblkDeviceData(acc)(values);
        }
        return parselsblkVolumeData(acc)(values);
      });

      return acc;
    };
  };
};

var parsefdisklDeviceData = exports.parsefdisklDeviceData = function parsefdisklDeviceData(getNodeId, createNewDevice) {
  return function (acc) {
    return function (_ref8) {
      var _ref9 = (0, _toArray3.default)(_ref8),
          head = _ref9[0],
          tail = _ref9.slice(1);

      var matches = head.match(/Disk\s(.*):\s.*,\s(\d+)\sbytes,\s(\d+) sectors/);
      if (matches == null) {
        throw new Error('parsefdisklDeviceData: error on parsing (head = ' + head + ')');
      }

      var _matches$slice = matches.slice(1),
          _matches$slice2 = (0, _slicedToArray3.default)(_matches$slice, 3),
          node = _matches$slice2[0],
          size = _matches$slice2[1],
          blocks = _matches$slice2[2];

      var id = getNodeId(node);
      if (!acc.devices[id]) {
        acc.devices[id] = createNewDevice(id, node);
      }
      acc.devices[id].blocks = parseInt(blocks);
      acc.devices[id].size = parseInt(size);
      tail.forEach(function (line) {
        if (line.match(/Sector.*:\s\d+\sbytes/)) {
          var _line$match$slice = line.match(/(\d+)\s.*\s(\d+)\s/).slice(1),
              _line$match$slice2 = (0, _slicedToArray3.default)(_line$match$slice, 2),
              logical = _line$match$slice2[0],
              physical = _line$match$slice2[1];

          acc.devices[id].blockSize = parseInt(physical);
          acc.devices[id].volumeBlockSize = parseInt(logical);
        }
      });
      return acc;
    };
  };
};

var parsefdisklVolumeData = exports.parsefdisklVolumeData = function parsefdisklVolumeData(getNodeId, createNewVolume) {
  return function (acc) {
    return function (lines) {
      return lines.reduce(function (acc, line) {
        var matches = line.match(/([\w\\/]+)\s+.*\s(\d+)\s+[\w.]+\s(.*)/);
        if (matches == null) {
          throw new Error('parsefdisklVolumeData: error on parsing (line = ' + line + ')');
        }

        var _matches$slice3 = matches.slice(1),
            _matches$slice4 = (0, _slicedToArray3.default)(_matches$slice3, 3),
            node = _matches$slice4[0],
            sectors = _matches$slice4[1],
            description = _matches$slice4[2];

        var id = getNodeId(node);
        if (!acc.volumes[id]) {
          acc.volumes[id] = createNewVolume(id, node);
        }
        acc.volumes[id].blocks = parseInt(sectors);
        acc.volumes[id].description = description;
        return acc;
      }, acc);
    };
  };
};

var parsefdiskl = exports.parsefdiskl = function parsefdiskl(parsefdisklDeviceData, parsefdisklVolumeData) {
  return function (fdiskl) {
    return function (acc) {
      var processblock = function processblock(block) {
        if (block[0].startsWith('Disk')) {
          return parsefdisklDeviceData(acc)(block);
        } else if (block[0].startsWith('Device')) {
          return parsefdisklVolumeData(acc)(block.slice(1));
        }
      };
      var lines = fdiskl.split('\n');
      var block = [];
      var i = 0;
      while (i < lines.length) {
        var item = lines[i];
        if (item === '' && block.length > 0) {
          // process previous block
          processblock(block);
          // start new block
          block = [];
        } else if (item !== '') {
          block.push(item);
        }
        i++;
      };
      return acc;
    };
  };
};

// split by space, except if space is preceeded by \ (paths with spaces)
// This is used instead of a negative lookbehind (`(?<!\\)\s+`)
var splitdfTLine = exports.splitdfTLine = function splitdfTLine(line) {
  return line.split(/\s+/).filter(function (s) {
    return s.trim();
  }).reduce(function (a, field) {
    if ((0, _utilities.lasti)(a) && (0, _utilities.lasti)((0, _utilities.lasti)(a)) === '\\') {
      a[a.length - 1] += ' ' + field;
    } else {
      a.push(field);
    }
    return a;
  }, []);
};

var parsedfT = exports.parsedfT = function parsedfT(getNodeId, createNewVolume, splitdfTLine) {
  return function (dft) {
    return function (acc) {
      var lines = dft.split('\n').filter(function (s) {
        return s.trim() && !(0, _utilities.hasSubstr)(s, 'tmpfs');
      }) // remove empty lines & tmp file systems
      .slice(1); // remove table header

      return lines.reduce(function (acc, line) {
        var _splitdfTLine = splitdfTLine(line),
            _splitdfTLine2 = (0, _slicedToArray3.default)(_splitdfTLine, 7),
            node = _splitdfTLine2[0],
            filesystem = _splitdfTLine2[1],
            size = _splitdfTLine2[2],
            used = _splitdfTLine2[3],
            available = _splitdfTLine2[4],
            mountPoint = _splitdfTLine2[6];

        var id = getNodeId(node);
        acc.volumes[id] = createNewVolume(id, node);
        acc.volumes[id].mounted = true;
        acc.volumes[id].mountPoint = mountPoint;
        acc.volumes[id].fs = filesystem === 'vfat' ? 'FAT32' : filesystem;
        acc.volumes[id].space.total = parseInt(size) * 1024;
        acc.volumes[id].space.available = parseInt(available) * 1024;
        acc.volumes[id].space.used = parseInt(used) * 1024;
        return acc;
      }, acc);
    };
  };
};

var parseLinux = exports.parseLinux = function parseLinux(mergeVolumesAndDevicesLinux, parselsblk, parsefdiskl, parsedfT) {
  return function (userFilter) {
    return function (output) {
      var parts = output.split('\n**********\n\n');

      var _parts = (0, _slicedToArray3.default)(parts, 3),
          dft = _parts[0],
          fdiskl = _parts[1],
          lsblk = _parts[2];

      var accumulator = compose(mergeVolumesAndDevicesLinux, parselsblk(lsblk), parsefdiskl(fdiskl), parsedfT(dft))({ devices: {}, volumes: {} });

      return {
        devices: filter(userFilter, accumulator.devices)
      };
    };
  };
};